# 📘 데이터분석 학습 노트

## 📅 2026-01-27
## 📌 데이터베이스의 기본

### 데이터베이스에서 가장 중요한 것
- 데이터베이스에서 핵심은 **SQL 문법이 아니라 ‘관계(Relationship)’ 이해**
- 실무에서 발생하는 SQL 오류의 상당수는  
  → 문법 오류가 아니라 **관계 이해 부족**에서 발생

---

### 관계를 이해하지 못하면 발생하는 실무 문제
- JOIN 후 데이터가 갑자기 **불어남**
- 반대로 데이터가 **사라짐**
- NULL이 생기는 구조를 모르고 필터링하여 정상 데이터가 누락됨
- 결과적으로
  - 지표 왜곡
  - 리포트 누락
  - “SQL은 맞는데 결과가 이상한” 상황 발생

---

## 🔗 관계 유형을 JOIN 관점에서 다시 정리

ERD의 관계(1:1, 1:N, M:N)는 설계 이론보다도  
**JOIN했을 때 결과 행(Row)이 어떻게 변하는지**,  
**어떤 JOIN을 쓰면 데이터가 누락되거나 증식되는지**를 판단하는 기준으로 해석하는 것이 중요하다.

---

## [1] 1:1 관계 (One-to-One) — JOIN 관점

### 핵심 구조
- A의 1행 ↔ B의 1행
- 실무에서는 **옵셔널(0..1)** 인 경우가 매우 많다  
  (예: 고객은 존재하지만 프로필은 없을 수 있음, 주문은 있지만 환불은 없을 수 있음)

### JOIN 결과 특징
- **JOIN해도 행(Row)은 원칙적으로 늘어나지 않는다**
- 다만, 옵셔널 관계일 경우
  - `LEFT JOIN` → B 테이블 컬럼에 `NULL` 발생
  - `INNER JOIN` → B가 없는 A의 행이 **누락**

### 실무 해석 포인트
- “한쪽 데이터가 없을 수 있는가?”를 먼저 판단해야 한다
- 기준 테이블(A) 중심 리포트라면  
  **INNER JOIN 사용 시 데이터 누락 위험**이 있다

📌  
1:1 관계의 핵심 리스크는 **행 증식이 아니라 행 누락**이다.

---

## [2] 1:N 관계 (One-to-Many) — JOIN 관점

### 핵심 구조
- A의 1행 ↔ B의 여러 행
- 한쪽(A)은 기준 데이터, 다른 쪽(B)은 반복 데이터  
  (예: 고객 1명 → 주문 여러 건)

### JOIN 결과 특징
- **JOIN하면 행(Row)이 늘어난다**
- A의 1행이 B의 개수만큼 **복제되어 나타난다**
  - 고객 1명 + 주문 3건 → 결과 3행

### 실무 해석 포인트
- JOIN 이후 결과의 **분석 단위가 무엇인지** 반드시 확인해야 한다
- 이 상태에서 단순 집계(`COUNT(*)`)를 하면
  - 고객 수가 아니라 **고객×주문 수**가 계산되는 오류 발생

📌  
1:N 관계에서 JOIN은  
**N쪽 기준으로 데이터가 늘어난다**는 점을 항상 경계해야 한다.

---

## [3] M:N 관계 (Many-to-Many) — JOIN 관점

### 핵심 구조
- A의 1행 ↔ B의 여러 행
- 동시에 B의 1행 ↔ A의 여러 행
- 관계형 DB에서는 **직접 저장하지 않고 중계 테이블로 분해**

---

### 핵심 사고 질문
> **이 데이터는 누구에 종속되는가?**

- 고객 기준 데이터인가?
- 주문 기준 데이터인가?
- 상품 기준 데이터인가?

👉 이 질문에 답하지 못하면 JOIN과 집계는 거의 항상 틀어짐

---

## 📌 식별자 (Identifier)

### 식별자의 정의
- “이 데이터가 바로 이것이다”라고 지정할 수 있게 해주는 값
- 하나의 속성 또는 **여러 속성의 조합**으로 구성 가능

---

### 식별자가 없으면 발생하는 문제
- 특정 데이터 조회 불가
- 중복 데이터 구분 불가
- 테이블 간 관계 설정 불가
- 수정·삭제 대상 명확히 지정 불가
- 식별자가 없는 데이터는  
  → **단순히 모여 있는 데이터 덩어리일 뿐**

---

### 엔터티 · 속성 · 식별자 예시
- 엔터티(Entity): 학생
- 속성(Attribute): 이름, 전공
- 식별자(Identifier): 학번

---

### 식별자의 종류

#### 기본키 (PK, Primary Key)
- 각 행을 유일하게 식별하는 대표 식별자
- 조건
  - 유일성 (중복 불가)
  - NULL 불가
  - 최소성

#### 외래키 (FK, Foreign Key)
- 다른 테이블의 PK를 참조
- 테이블 간의 **다리 역할**
- JOIN의 근거

#### 후보키 (Candidate Key)
- 기본키가 될 수 있는 모든 식별자 후보
- 예: 학번, 주민등록번호

---

### 자연키 vs 인조키
- 자연키(Natural Key)
  - 업무적 의미 있음
  - 원래 존재하는 속성
- 인조키(Surrogate Key)
  - 업무적 의미 없음
  - 시스템을 위해 인위적으로 생성

---

## 📌 분석가 관점의 데이터 모델링

### 분석가에게 데이터 모델링이 중요한 이유
- 데이터가 어떤 기준으로 쪼개져 저장되어 있는지 이해
- 어떤 테이블을 JOIN 해야 하는지 판단 가능
- 지표 정의 시
  - 중복
  - 누락
  - 과대/과소 집계  
  위험을 사전에 인지 가능

📌 비유  
> **데이터베이스는 건축의 ‘설계도’와 같다**

---

### 데이터 모델링 단계

#### 개념적 모델링
- “이 비즈니스에는 어떤 데이터가 존재하는가?”
- ERD의 뼈대를 만드는 단계
- 기획자·마케터·개발자의 공통 언어

#### 논리적 모델링
- “이 데이터를 어떤 구조로 저장할 것인가?”
- 엔터티 → 테이블
- 속성 → 컬럼
- 관계 → PK / FK
- 정규화를 통해 중복 제거, 일관성 확보
- 속성과 관계가 상세히 표현된 ERD 작성

#### 물리적 모델링
- “이 구조를 실제 DB에 어떻게 구현할 것인가?”
- 특정 DBMS 환경에서 실제 구현
- 분석가는
  - 인덱스 컬럼 파악
  - 물리 모델을 읽을 수 있는 수준 필요

---

## 📌 데이터베이스 설계와 ERD

### ERD란?
- 데이터 모델링 결과를 시각적으로 표현한 설계도
- 실무 활용
  - 신규 분석 과제 시작 시 데이터 구조 파악
  - 개발자·기획자·분석가 간 데이터 구조 합의 도구

📌 실무에서는  
→ SQL 코드보다 **ERD를 먼저 보는 경우가 많음**

---

### ERD 해석 시 반드시 던져야 할 질문
- 이 테이블의 한 행은 무엇을 의미하는가?
- 이 관계는 왜 1:N인가?
- 이 구조에서 JOIN은 어디서 발생하는가?

---

### ERD 구성 요소
#### 엔터티
- 데이터로 관리해야 할 대상
- 엔터티 1개 = 테이블 1개
- 잘못 나누면
  - 테이블 비대화
  - 과도한 JOIN 발생

#### 속성
- 엔터티가 가지는 구체적인 정보
- 테이블의 컬럼
- 여러 의미가 섞인 컬럼은 정규화 대상

#### 관계
- 엔터티 간 비즈니스 규칙
- 선(Line)으로 표현
- 이 선 하나가 JOIN의 근거

---

### ERD 기호 (Crow’s Foot Notation)

#### 카디널리티 (최대 개수)
- `|` : 하나
- `<` : 다수

#### 선택성 (최소 개수)
- `O` : 선택 (0 가능)
- `|` : 필수 (1 이상)

→ NULL 발생 가능성 판단 기준

---

### 기호 조합 실무 해석
- `O|`
  → NULL이 나와도 정상
- `||`
  → JOIN해도 데이터 안전
- `O<`
  → JOIN하면 데이터 폭증
- `|<`
  → JOIN 없이는 의미 없는 데이터

---

## 📌 데이터베이스 관계 (Relationship)

### 관계란?
- 테이블 간의 논리적 연결
- 데이터가 늘어나는 방식, 사라지는 조건, NULL 발생 여부를 결정

---

### 관계를 위한 핵심 요소
- 기본키(PK): 이 행이 무엇인지 결정
- 외래키(FK): 다른 테이블의 PK 참조

📌 키는 단순 제약조건이 아니라  
→ **JOIN의 근거 + 데이터 소속 관계**

---

### 1:1 관계
- 주로 ‘분리’ 목적
  - 민감정보 분리
  - 선택적 정보 분리
  - 대용량 데이터 분리

📌 해석 포인트
- 한쪽 데이터가 없을 수 있는지 먼저 확인
- INNER JOIN 시 데이터 누락 가능

---

### 1:N 관계 ⭐ 가장 중요
- JOIN 시 반드시 행(Row)이 늘어남
- 고객 1명 + 주문 3건 → 결과 3행

📌 규칙
> **1:N 관계에서 JOIN하면 N쪽 기준으로 데이터가 늘어난다**

- COUNT(*)는 항상 “무엇을 세고 있는지” 확인

---

### M:N 관계
- 고객 ↔ 상품 = M:N
- 주문 테이블이 중계 테이블 역할
- 관계형 DB에서는
  → 반드시 중계 테이블로 구조 분해

---

### 관계 파트 핵심 요약
- SQL 오류의 대부분은
  → **관계 이해 부족에서 시작된다** 

---
   
## 🧐 오늘의 궁금증

### ERD는 데이터 분석가에게 왜 필요할까?

처음에는 ERD가 데이터베이스 설계 문서처럼 보였지만,  
분석 관점에서 핵심 역할은 **“JOIN을 어떻게 해야 하는지 판단하기 위한 지도”**라는 점을 이해하게 되었다.

데이터 분석가는 ERD를 통해  
- 어떤 테이블을 어떤 키로 JOIN해야 하는지  
- JOIN 시 행(row)이 증가하는지  
- 집계(aggregation)가 선행되어야 하는 테이블인지  
를 빠르게 판단할 수 있다.

---

### 중계 테이블은 왜 중요한가?

중계 테이블은 보통 **M:N 관계**를 표현하며,  
`user_id + 다른_id` 형태의 **관계/행위 로그**가 저장된다.

분석 관점에서 중요한 점은  
> **중계 테이블을 그대로 JOIN하면 데이터가 증식될 가능성이 매우 높다**는 것이다.

따라서 중계 테이블은 대부분  
**집계 → 의미 단위 고정 → JOIN**  
이라는 순서를 따라야 지표 왜곡을 피할 수 있다.

---

### “한 칸에 하나의 값” 기준은 충분할까?

- 한 컬럼에 여러 값이 들어가면 → **테이블 분리**는 맞다.
- 하지만 분리된 테이블이  
  - 두 엔티티 간 **관계 기록(누가–무엇을–언제)** 이면 → **중계 테이블**
  - 내용·텍스트·사건 자체를 담고 있으면 → **독립 엔티티**

즉, “여러 개”라는 이유만으로 중계 테이블은 아니다.

---

### ERD 없이도 중계 테이블을 감지할 수 있을까?

가능하다. 다음 신호가 보이면 중계 테이블일 확률이 높다.

- 컬럼이 거의 전부 `~_id`
- 복합 PK 사용
- row 수가 유독 많음
- JOIN 시 행이 급격히 증가
- “누가 무엇을 언제 했다” 구조

이런 경우 분석가는 **바로 집계부터 고려**해야 한다.

---

### 오늘의 핵심 정리

- 데이터 분석가에게 ERD는 설계 이론을 설명하기 위한 문서가 아니다.
- ERD의 핵심 가치는  
  **JOIN 방향, 집계 필요 여부, 분석 단위(Granularity)를 판단하는 데 있다.**
- “왜 중계 테이블인지”를 말로 설명할 수 없더라도,  
  **중계 테이블처럼 행동(집계 후 JOIN)** 할 수 있으면 충분하다.

---
## 📅 2026-01-29
## 📌 SELECT 구조와 실행 순서 이해

### SQL에서 SELECT가 중요한 이유
- SQL의 모든 분석은 **SELECT 문에서 시작**
- 조회 대상, 분석 단위, 집계 기준이  
  → SELECT 구조에 의해 결정됨

📌  
SQL에서 발생하는 많은 오류는  
문법이 아니라 **실행 순서와 구조 이해 부족**에서 발생한다.

---

### SELECT 구문의 기본 구조
- SELECT
- FROM
- WHERE
- GROUP BY
- HAVING
- ORDER BY
- LIMIT / OFFSET

- SQL은 자유 문장이 아니라  
  **정해진 구조와 순서를 따르는 언어**
- 구문의 순서를 지키지 않으면 실행되지 않음

---

### SELECT 구문의 작성 순서
```sql
SELECT
FROM
WHERE
GROUP BY
HAVING
ORDER BY
LIMIT
````

#### 올바른 작성 예시

```sql
SELECT Name, Population
FROM city;
```

#### 잘못된 작성 예시 (실행 불가)

```sql
-- FROM city
-- SELECT Name, Population
```

📌
SQL은 사람이 읽는 순서가 아니라
**DB 엔진의 처리 순서**를 기준으로 해석된다.

---

## 📌 SELECT 절과 FROM 절의 역할

### SELECT 절

* 조회하고 싶은 **컬럼을 지정**
* 분석에서 “무엇을 보겠는가”를 결정

```sql
SELECT Name, Population
FROM city;
```

---

### FROM 절

* 데이터의 **출처를 명확히 지정**
* FROM이 없으면 SELECT는 의미를 가질 수 없음

---

### `SELECT *` 사용 시 주의

```sql
SELECT *
FROM city;
```

* 테이블 구조 확인용으로만 제한적으로 사용
* 실무/분석 쿼리에서는 지양

📌
분석에서는
**필요한 컬럼만 명시적으로 선택하는 것이 원칙**이다.
컬럼을 고르는 행위 자체가 분석 의도다.

---

### 특정 컬럼 조회 시 권장 방식

```sql
SELECT city.Name, city.Population
FROM city;
```

* 테이블이 하나여도 `테이블명.컬럼명` 사용 권장
* 이후 JOIN이 추가되어도 컬럼 출처가 명확함

📌
컬럼 출처를 명확히 쓰는 습관은
ERD 해석, 관계 이해, JOIN 사고 예방으로 이어진다.

---

## 📌 SELECT에서 자주 사용하는 기능

### 별칭 설정 (Alias)

* 컬럼명, 테이블명 모두 별칭 설정 가능
* 가독성과 의미 전달을 동시에 개선

```sql
SELECT
    city.Name AS city_name,
    city.Population AS pop
FROM city;
```

📌
별칭은 단순 축약이 아니라
**“이 컬럼을 어떤 의미로 쓰겠다”는 선언**이다.

---

### DISTINCT

* 컬럼 내 **고유 값의 종류를 빠르게 파악**
* 데이터 분포 확인에 유용

```sql
SELECT DISTINCT countrycode
FROM city;
```

📌
DISTINCT는
범주형 데이터의 수준(level)을 빠르게 파악할 때 유용하지만,
여러 컬럼과 함께 사용할 경우
**중복 제거 기준을 반드시 의식해야 한다.**

---

## 📌 SQL의 논리적 실행 순서

### 작성 순서 vs 실행 순서

```text
[작성 순서]
SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY → LIMIT

[실행 순서]
FROM
→ WHERE
→ GROUP BY
→ HAVING
→ SELECT
→ ORDER BY
→ LIMIT
```

📌
SELECT에서 만든 별칭은
WHERE 절에서 사용할 수 없다.
→ **WHERE가 SELECT보다 먼저 실행되기 때문**

---

## 📌 WHERE와 HAVING의 차이

### 공통점

* 둘 다 **필터링 역할**

### 차이점

| 구분       | WHERE       | HAVING      |
| -------- | ----------- | ----------- |
| 적용 대상    | 개별 행(Row)   | 그룹화된 결과     |
| 적용 시점    | GROUP BY 이전 | GROUP BY 이후 |
| 집계 함수 사용 | ❌           | ⭕           |

📌

* WHERE → **먼저 버리고 계산**
* HAVING → **다 계산한 후 조건 적용**

이 차이를 이해하지 못하면
분석 대상이 바뀌거나 집계 결과가 왜곡된다.

---

## 📌 GROUP BY 이해

### GROUP BY란?

* 지정된 컬럼 기준으로 데이터를 그룹화
* 각 그룹에 대해 집계 함수 사용 가능

```text
여러 행
→ 하나의 그룹
→ 하나의 결과 행
```

---

### GROUP BY의 목적

* 같은 값을 가진 레코드를 묶어
  **요약·집계 정보 생성**

예:

* 고객별 주문 수
* 국가별 인구 합계
* 상품별 매출

---

### GROUP BY의 핵심 사고

* 그룹화: **분석 단위를 고정하는 작업**
* 집계: SELECT 절에서 수행

```sql
SELECT
    CountryCode,
    SUM(Population) AS total_population
FROM city
GROUP BY CountryCode;
```

📌
GROUP BY는 단순 문법이 아니라
**“이 분석은 무엇을 단위로 보는가”를 결정하는 핵심 구문**이다.

---

## 📌 HAVING으로 그룹 결과 필터링

```sql
SELECT
    CountryCode,
    SUM(Population) AS total_population
FROM city
GROUP BY CountryCode
HAVING SUM(Population) > 10000000;
```

* HAVING은 그룹화된 결과에 조건 적용

📌
HAVING은
집계 결과 자체가 조건일 때만 사용해야 하며,
가능하다면 **WHERE로 먼저 거르는 것이 원칙**이다.

---

### 오늘의 핵심 정리

- 데이터 분석가에게 SQL 문법은 목적이 아니라 **수단**이다.
- SELECT, WHERE, GROUP BY, HAVING의 핵심은  
  **“어떤 데이터를, 어떤 단위로, 언제 거르는가”를 통제하는 데 있다.**
- GROUP BY는 단순 집계 문법이 아니라  
  **분석 단위(Granularity)를 명시적으로 고정하는 행위**다.
- WHERE와 HAVING의 차이를 이해하지 못하면  
  분석 대상이 바뀌거나 집계 결과가 왜곡된다.
- 실행 순서(FROM → WHERE → GROUP BY → HAVING → SELECT)를 이해해야  
  별칭 오류, 필터링 오류, 지표 해석 오류를 예방할 수 있다.
---
